#include "msp430.h"                     ; #define controlled include file
        NAME    main                    ; module name
        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        ORG     01C00h                  ; start of ram

//PRE-DEFINED VALUES START HERE

; Digits    0     1     2     3     4     5     6     7     8     9
digitH  db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xF7
digitL  db 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

; Oper      /     +     -     *
operH   db 0x00, 0x03, 0x03, 0x03
operL   db 0x28, 0x50, 0x00, 0xFA

; Error     E     R     O
errorH  db 0x9E, 0xCF, 0xFC
errorL  db 0x00, 0x02, 0x00

//PRE-DEFINED VALUES END HERE

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   mov     #SFE(CSTACK), SP        ; set up stack

main:   nop                             ; main program
        mov     #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer
        mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
        bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as
                                        ; as pull-down
        ; Enable LCD segments
        mov     #0xffff,&LCDCPCTL0
        mov     #0xfc3f,&LCDCPCTL1
        mov     #0x0fff,&LCDCPCTL2
        
        mov     #0x041e,&LCDCCTL0       ; Initialize LCD_C
        mov     #0x0208,&LCDCVCTL       ; Initialize voltage
        mov     #0x8000,&LCDCCPCTL      ; Clock synchronization enabled
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        bis     #1,&LCDCCTL0            ; Turn LCD on
        bic     #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on by default

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
setupCalc:
        mov     #0,R5                   ; Represents the first number the
                                        ; user has inputted 
        mov     #0,R6                   ; Represents the second number the
                                        ; user has inputted 
        mov     #0,R7                   ; Represents the third number the
                                        ; user has inputted 
        mov     #0,R8                   ; Represent the state, the program is on
        mov     #0,R9                   ; Used for knowing the number/operation
                                        ; to display next    
        mov     #0,R10                  ; Represents the first number the
                                        ; user has inputted 
        mov     #0,R11                  ; Represents the second number the
                                        ; user has inputted 
        mov     #0,R12                  ; Represents the third number the
                                        ; user has inputted    
        mov     #0,R14                  ; Represents the first full number the
                                        ; user inputted
        mov     #0,R15                  ; Represents the second full number the
                                        ; user inputted
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        call    #displayNumber          ; Display 0 to the user

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
mainLoop:                               ; The brains of the application
        mov.b   &P1IN,R4                ; Copy into R4 P1IN's byte
        cmp     #4,R4                   ; Compare if its the left button
        jeq     pressed                 ; Left button was pressed
        cmp     #2,R4                   ; Compares if its the right button
        jeq     pressed                 ; Right button is pressed
        jnz     mainLoop                ; Keep waiting for user input
    
    pressed:                            ; Button was pressed now we wait
        push    R4                      ; Save the button that was pressed
        call    #delay                  ; Delay to help combat button bouncing
        call    #stillHoldDown          ; Verify if the user is still holding 
                                        ; down the button
        pop     R4                      ; Retrieve the button that was pressed

    checkState:                         ; Checks the state of the application
                                        ; and decide what to do next
        cmp     #3,R8                   ; If state is less than 3 means that the 
        jl      incNumberLoop           ; user is still inputting the number
        jeq     incOperationLoop        ; User is now inputting an operation
        cmp     #7,R8                   ; If state is less than 6 means that the
        jl      incNumberLoop           ; user is still inputting the number 
    resetCalc:                          ; User is done with the results now restart
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     setupCalc               ; If true then restart calculator
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     setupCalc               ; If true then restart calculator
        cmp.b   #00000000B,R4           ; Compares if both button are 
                                        ; being pressed
        jeq     setupCalc               ; If true then restart calculator

    incNumberLoop:                      ; Loop for incrementing the number
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     nextNumber              ; If true then increment the number
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     nextState               ; User has decided to input next number
        jmp     mainLoop                ; Keep waiting for user input

    incOperationLoop:                   ; Cycles through the operations
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     nextOperation           ; If true then change the operation
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     operationSelected       ; User has decided the operation, so now
                                        ; we reset to display the next number
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
nextNumber:                             ; Loops through numbers 0-9
        cmp     #9,R9                   ; Resets the number back to 0 meaning
        jeq     resetNumber             ; the user has accidentaly missed the 
                                        ; desired number
        inc     R9                      ; Increment the number by 1
        call    #displayNumber          ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
resetNumber:                            ; Resets the number back to 0
        mov     #0,R9                   ; Number is set back to 0
        call    #displayNumber          ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
nextState:                              ; Moves to the next state of the application
        push    R9                      ; Save the number in the stack
        mov     #0,R9                   ; Reset R9
        inc     R8                      ; Increment to the next state
        cmp     #3,R8                   ; If the program is on stage 3 then
        jeq     nextOperation           ; now we display the operation 
        cmp     #7,R8                   ; If the program is on stage 7 then the
        jeq     doTheMath               ; user has finish inputting all the data
                                        ; and is now expecting an answer
        call    #displayNumber          ; Display the next digit to the user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
nextOperation:                          ; Loops through operations +,-,*,/
        cmp     #3,R9                   ; Resets the number back to 0 meaning
        jeq     resetOperation          ; the user has accidentaly missed the 
                                        ; desired operation
        inc     R9                      ; Increment to the next operation
        call    #displayOperation       ; Display the next operation to the user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
resetOperation:                         ; Reset operation back to +
        mov     #0,R9                   ; Number is set back to 0
        call    #displayOperation       ; Display the next operation to the user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
operationSelected:                      ; User has decided the operation
        inc     R8                      ; Increment to the next state
        push    R9                      ; Save the operation in the stack
        mov     #0,R9                   ; Reset R9
        call    #displayNumber          ; Display 0 to the user
        jmp mainLoop                    ; Keep waiting for user input

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
stillHoldDown:                          ; User is still holding down the button
        mov.b   &P1IN,R4                ; Copy into R4 P1IN's byte
        and.b   #00000110B,R4           ; Compares which button is being pressed
        cmp.b   #00000100B,R4           ; Left button (P1.1) is being pressed
        jeq     stillHoldDown           ; If true wait for user to stop holding 
                                        ; down the button
        cmp.b   #00000010B,R4           ; Right button (P1.2) is being pressed
        jeq     stillHoldDown           ; If true wait for user to stop holding 
                                        ; down the button
        call    #delay                  ; Delay to help combat button bouncing
        ret                             ; User has finally let go of the button

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
delay:                                  ; Used to help against button bouncing
        mov     #0x2710,R13             ; Represents the delay to wait for
                                        ; button bouncing
    decrement:                          ; Label used for looping
        dec     R13                     ; Decrement delay by 1
        jnz     decrement               ; Keep Looping until delay = 0
        ret                             ; Delay finished

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
doTheMath:                              ; Mathimatical brain of the application
        pop     R12                     ; Least significant digit of second number
        pop     R11                     ; Second significant digit of second number
        pop     R10                     ; Most significant digit of second number
        pop     R9                      ; Represents the operation
        pop     R7                      ; Least significant digit of first number
        pop     R6                      ; Second significant digit of first number
        pop     R5                      ; Most significant digit of first number
        call    #combineDigits          ; Subroutine for combining digits
        cmp     #1,R9                   ; R9=1 means the operation chosen is add
        jeq     addNumbers              ; Call the add operation
        cmp     #2,R9                   ; R9=2 means the operation chosen is sub
        jeq     subNumbers              ; Call the sub operation
        cmp     #3,R9                   ; R9=3 means the operation chosen is mul
        jeq     mulNumbers              ; Call the mul operation
        cmp     #0,R9                   ; R9=0 means the operation chosen is dev
        jeq     devNumbers              ; Call the dev operation

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
combineDigits:                          ; Subroutine for combining digits
    firstDigitCombine:   
        cmp     #0,R5
        jeq     secondDigitCombine
        add     #100, R14               ; This subroutine will add 100 to R14 
        dec     R5                      ; and decrease R5 by one until R5 is 0
        jmp     firstDigitCombine
    secondDigitCombine:     
        cmp     #0,R6
        jeq     thirdDigitCombine
        add     #10, R14                ; This subroutine will add 10 to R14 
        dec     R6                      ; and decrease R6 by one until R6 is 0
        jmp     secondDigitCombine
    thirdDigitCombine:      
        add     R7, R14                 ; This will add the last digit to R14

    firstDigitCombine2:     
        cmp     #0,R10
        jeq     secondDigitCombine2
        add     #100, R15               ; This subroutine will add 100 to R14 
        dec     R10                     ; and decrease R5 by one until R5 is 0
        jmp     firstDigitCombine2
    secondDigitCombine2:    
        cmp     #0,R11
        jeq     thirdDigitCombine2
        add     #10, R15                ; This subroutine will add 100 to R14 
        dec     R11                     ; and decrease R5 by one until R5 is 0
        jmp     secondDigitCombine2
    thirdDigitCombine2:     
        add     R12, R15                ; This will add the last digit to R15
        ret

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
addNumbers:                             ; Operation for adding 2 numbers
        add     R15,R14                 ; Adds numbers in R14 and R15 and
                                        ; stores the result in R14
        mov     #0,R15                  ; Set R15 to 0 because we need it later
        cmp     #0,R14                  ; Check if the result = 0
        jeq     display0                ; If result = 0 then display 0
        jmp     seperateDigits          ; Seperate the digits into diferent registers
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
mulNumbers:                             ; Operation for multiplying 2 numbers
        cmp     #0,R15                  ; Check if the R15 = 0
        jeq     display0                ; If R15 = 0 then result = 0 
        cmp     #0,R14                  ; Check if the R14 = 0
        jeq     display0                ; If R14 = 0 then result = 0 
    multSetup:                          ; Setup numbers in the proper order
                                        ; for multiplication
        cmp     R14, R15                ; Compare which number is bigger
        jl      multAlgorithm           ; If R14>R15 then multiply both numbers
        call    #multSwitchNumbers      ; If R15>R14 then reverse both numbers
    multAlgorithm:                      ; Algorithm for multiplying 2 numbers
        mov     R14, R6                 ; Re-aranging data for multiplication
        mov     R15, R7                 ; Re-aranging data for multiplication
        mov     #0, R15                 ; Set R15 to 0 because we need it later
    multLoop:                           ; Lable used for looping
        dec     R7                      ; Decrement by 1
        jz      multDone                ; Multiplication is finished
        add     R6, R14                 ; Remember that multiplication is
                                        ; just a series of additions
        cmp     #10000, R14             ; If R14 is greater or equal than 1000
        jge     multReachedThousand     ; save that thousand on another register
        jmp     multLoop                ; Multiplication not done
    multDone:                           ; Multiplication finished
        jmp     seperateDigits          ; Seperate the digits into diferent registers
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
multReachedThousand:                    ; Save that thousand on R15
        sub     #10000,R14              ; Sub 1000-R14 so we can move that to R15
        inc     R15                     ; Increment 1 meaning the first thousand
        jmp     multLoop                ; Go back to multiplying

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
multSwitchNumbers:                      ; Invert the data on both R14 and R15
        push     R15                    ; Pushed to the stack so we dont 
                                        ; override the data
        mov      R14, R15               ; Swap R14 to R15
        pop      R14                    ; Retrieve the data from the stack
        ret                             ; Swapping done

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
subNumbers:                             ; Operation for subtracting 2 numbers
        sub     R15, R14                ; R14 = R14 - R15
        mov     #0,R15                  ; Set R15 to 0 because we need it later
        cmp     #0,R14                  ; Check if the result = 0
        jeq     display0                ; If result = 0 then display 0
        jmp     seperateDigits          ; Seperate the digits into diferent registers
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
devNumbers:                             ; Operation for deviding 2 numbers
        cmp     #0,R15                  ; Check if the denominator is 0
        jeq     ceroIsOnDenominator     ; If 0 then show error
        cmp     #0,R14                  ; Check if the numerator is 0
        jeq     ceroIsOnNumerator       ; If 0 then result = 0
        mov     #0, R5                  ; R5 = quotient = 0   
        
    divLoop:                            ; Lable used for looping
        sub     R15, R14                ; R14 = R14 - R15
        cmp     #0, R14                 ; Compare to see if we can keep subtracting
        jl      divEnd                  ; R14 < 0, its negative so we subtracted
                                        ; too much
        inc     R5                      ; Quotient += 1
        jmp     divLoop                 ; Keep dividing    
   
    divEnd:                             ; Division finished
        mov     R5, R14                 ; Save result in R14
        mov     #0,R15                  ; Set R15 to 0 because we need it later
        cmp     #0,R14                  ; Check if the result = 0
        jeq     display0                ; If result = 0 then display 0
        jmp     seperateDigits          ; Seperate the digits into diferent registers
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
ceroIsOnNumerator:                      ; Cero is on numerator meaning result=0
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        call    #displayFirstSegment    ; Display number to user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
ceroIsOnDenominator:                    ; Cero is on denominator meaning an error
        call    #displayError           ; Display error to user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
display0:
        mov     #0,R9
        call    displayFirstSegment  
        jmp     mainLoop

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
seperateDigits: ; separeates R14 into its decimal components
        cmp     #2, R9          ; Subtraction, always 3 digits, 
        jeq     sepDigSub       ; but sometimes its negative
        jmp     seperate

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
sepDigSub: ; checks if R14 is negative
        push    R14             ; store R14 in stack
        and     #1000000000000000b, R14 ; apply bit mask
                                ; if most significant bit is 1, then its a negative number
        cmp     #0,R14         ; if R14 == 0, then most significant bit is 0
        pop     R14             ; restore value of R14
        jeq     seperate     ; R14 is a positive number
        jmp     applyNegative  ; R14 is a negative number

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
applyNegative: 
        inv     R14             ; convert R14 to positive, first invert everything,
        inc     R14             ; then add 1
        mov     #1,R13         ; add negative flag
        jmp     seperate

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
seperate: 
        mov     #3,R12
        mov     #0,R11
    loop:
        dec     R12
        mov     #0, R9          ; R9 = quotient = 0
        cmp     #1,R12
        jeq      ones
        cmp     #2,R12
        jeq      tens
        cmp     #3,R12
        jeq     hundreds
        cmp     #0,R12
        jeq     otherRegister
        jmp     thousands
        
    otherRegister:
        cmp     #6,R11
        jeq     finished
        mov     R14,R15
        mov     #0,R14
        mov     #5,R12
        jmp     loop
    
    ones:
        mov     R15,R9
        mov     #0,R15
        jmp     loopDone

    tens:
        mov     #10,R4
        jmp     loopDigit
        
    hundreds:
        mov     #100,R4
        jmp     loopDigit
        
    thousands:
        mov     #1000,R4
        jmp     loopDigit
    
        
    loopDigit:
        cmp     R4,R15
        jl      loopDone
        sub     R4,R15
        inc     R9
        jmp     loopDigit 
    
    loopDone:
        push    R9
        inc     R11
        jmp     loop

    finished:
        pop     R12
        pop     R11
        pop     R10
        pop     R7
        pop     R6
        pop     R5
        push    R12
        push    R11
        push    R10
        push    R7
        push    R6
        push    R5
        jmp     displayResults  

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
displayResults:
        mov     #7,R10
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        mov     #0,R11
        jmp     displayNextDigit
    displayNextDigit:
        dec     R10
        cmp     #0,R10
        jeq     resultsDone
        pop     R9
        cmp     #1,R11                          ; No mores zeros to the left
        jge     noMoreLeftZeros                 ; of the number
        cmp     #0,R9
        jeq     displayNextDigit
    noMoreLeftZeros:
        inc     R11
        cmp     #1,R11
        jeq     displayFirstDigit
        cmp     #2,R11
        jeq     displaySecondDigit
        cmp     #3,R11
        jeq     displayThirdDigit
        cmp     #4,R11
        jeq     displayFourthDigit
        cmp     #5,R11
        jeq     displayFifthDigit
        cmp     #6,R11
        jeq     displaySixthDigit
        
    displayFirstDigit:
        call    #displayFirstSegment
        cmp     #1,R13
        jeq     displayNegative
        jmp     displayNextDigit
        
    displaySecondDigit:
        call    #displaySecondSegment
        jmp     displayNextDigit
        
    displayThirdDigit:
        call    #displayThirdSegment
        jmp     displayNextDigit
        
    displayFourthDigit:
        call    #displayFourthSegment
        jmp     displayNextDigit  
        
    displayFifthDigit:
        call    #displayFifthSegment
        jmp     displayNextDigit 
        
    displaySixthDigit:
        call    #displaySixthSegment
        jmp     displayNextDigit 
        
    resultsDone:
        jmp     mainLoop

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
displayNegative:
        bis.b   #4,&0x0A29+1
        jmp     displayNextDigit

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
displayNumber:
        cmp     #0,R8
        jeq     displayFirstSegment
        cmp     #1,R8
        jeq     displaySecondSegment
        cmp     #2,R8
        jeq     displayThirdSegment
        cmp     #3,R8
        jeq     displayOperation
        cmp     #4,R8
        jeq     displayFirstSegment
        cmp     #5,R8
        jeq     displaySecondSegment
        cmp     #6,R8
        jeq     displayThirdSegment

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
displayOperation:
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        mov.b   operH(R9),&0x0A29
        mov.b   operL(R9),&0x0A29+1
        ret

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
displayError:
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        mov     #0,R9
        mov.b   errorH(R9),&0x0A29
        mov.b   errorL(R9),&0x0A29+1
        mov     #1,R9
        mov.b   errorH(R9),&0x0A25
        mov.b   errorL(R9),&0x0A25+1
        mov     #1,R9
        mov.b   errorH(R9),&0x0A23
        mov.b   errorL(R9),&0x0A23+1
        mov     #2,R9
        mov.b   errorH(R9),&0x0A32
        mov.b   errorL(R9),&0x0A32+1
        mov     #1,R9
        mov.b   errorH(R9),&0x0A2E
        mov.b   errorL(R9),&0x0A2E+1
        jmp     mainLoop

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
displayFirstSegment:
        mov.b   digitH(R9),&0x0A29
        mov.b   digitL(R9),&0x0A29+1
        ret

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
displaySecondSegment:
        mov.b   digitH(R9),&0x0A25
        mov.b   digitL(R9),&0x0A25+1
        ret

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
displayThirdSegment:
        mov.b   digitH(R9),&0x0A23
        mov.b   digitL(R9),&0x0A23+1
        ret

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
displayFourthSegment:
        mov.b   digitH(R9),&0x0A32
        mov.b   digitL(R9),&0x0A32+1
        ret

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
displayFifthSegment:
        mov.b   digitH(R9),&0x0A2E
        mov.b   digitL(R9),&0x0A2E+1
        ret

// Objetivo:
// Precondiciones:
// Postcondiciones:
// Autor:
// Fecha:
displaySixthSegment:
        mov.b   digitH(R9),&0x0A27
        mov.b   digitL(R9),&0x0A27+1
        ret

fin:    JMP $                           ; jump to current location '$'
                                        ; (endless loop)
        END
