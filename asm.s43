#include "msp430.h"                     ; #define controlled include file
        NAME    main                    ; module name
        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        ORG     01C00h                  ; start of ram
//PRE-DEFINED VALUES START HERE
; Digits    0     1     2     3     4     5     6     7     8     9
digitH  db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xF7
digitL  db 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
; Oper      /     +     -     *
operH   db 0x00, 0x03, 0x03, 0x03
operL   db 0x28, 0x50, 0x00, 0xFA
; Error     E     R     O
errorH  db 0x9E, 0xCF, 0xFC
errorL  db 0x00, 0x02, 0x00
//PRE-DEFINED VALUES END HERE
        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   mov     #SFE(CSTACK), SP        ; set up stack

main:   nop                             ; main program
        mov     #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer
        mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
        bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as
                                        ; as pull-down
        ; Enable LCD segments
        mov     #0xffff,&LCDCPCTL0
        mov     #0xfc3f,&LCDCPCTL1
        mov     #0x0fff,&LCDCPCTL2
        
        mov     #0x041e,&LCDCCTL0       ; Initialize LCD_C
        mov     #0x0208,&LCDCVCTL       ; Initialize voltage
        mov     #0x8000,&LCDCCPCTL      ; Clock synchronization enabled
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        bis     #1,&LCDCCTL0            ; Turn LCD on
        bic     #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on by default

// Objetivo: Set up calculator variables (Registors) and inistialize the display
// Precondiciones:Registors 5-7 = first 3 digits, R8 = state of app, R9 = number/operation
// Registors 10-12 = second 3 digits, R14 = first number, R14 = second number
// Postcondiciones:N/A
// Autor: Daniel A. Crespo 
// Fecha:11/Mar/2021
setupCalc:
        mov     #0,R5                   ; Represents the first number the
                                        ; user has inputted 
        mov     #0,R6                   ; Represents the second number the
                                        ; user has inputted 
        mov     #0,R7                   ; Represents the third number the
                                        ; user has inputted 
        mov     #0,R8                   ; Represent the state, the program is on
        mov     #0,R9                   ; Used for knowing the number/operation
                                        ; to display next    
        mov     #0,R10                  ; Represents the first number the
                                        ; user has inputted 
        mov     #0,R11                  ; Represents the second number the
                                        ; user has inputted 
        mov     #0,R12                  ; Represents the third number the
                                        ; user has inputted    
        mov     #0,R14                  ; Represents the first full number the
                                        ; user inputted
        mov     #0,R15                  ; Represents the second full number the
                                        ; user inputted
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        call    #displayNumber          ; Display 0 to the user

// Objetivo: This is the brains of the calculator that manages everything
// Precondiciones: N/A
// Postcondiciones: N/A
// Autor: Daniel A. Crespo 
// Fecha:11/Mar/2021
mainLoop:                               ; The brains of the application
        mov.b   &P1IN,R4                ; Copy into R4 P1IN's byte
        cmp     #4,R4                   ; Compare if its the left button
        jeq     pressed                 ; Left button was pressed
        cmp     #2,R4                   ; Compares if its the right button
        jeq     pressed                 ; Right button is pressed
        jnz     mainLoop                ; Keep waiting for user input
    
    pressed:                            ; Button was pressed now we wait
        push    R4                      ; Save the button that was pressed
        call    #delay                  ; Delay to help combat button bouncing
        call    #stillHoldDown          ; Verify if the user is still holding 
                                        ; down the button
        pop     R4                      ; Retrieve the button that was pressed

    checkState:                         ; Checks the state of the application
                                        ; and decide what to do next
        cmp     #3,R8                   ; If state is less than 3 means that the 
        jl      incNumberLoop           ; user is still inputting the number
        jeq     incOperationLoop        ; User is now inputting an operation
        cmp     #7,R8                   ; If state is less than 6 means that the
        jl      incNumberLoop           ; user is still inputting the number 
    resetCalc:                          ; User is done with the results now restart
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     setupCalc               ; If true then restart calculator
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     setupCalc               ; If true then restart calculator
        cmp.b   #00000000B,R4           ; Compares if both button are 
                                        ; being pressed
        jeq     setupCalc               ; If true then restart calculator

    incNumberLoop:                      ; Loop for incrementing the number
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     nextNumber              ; If true then increment the number
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     nextState               ; User has decided to input next number
        jmp     mainLoop                ; Keep waiting for user input

    incOperationLoop:                   ; Cycles through the operations
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     nextOperation           ; If true then change the operation
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     operationSelected       ; User has decided the operation, so now
                                        ; we reset to display the next number
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: Display numbers 1-9
// Precondiciones: R8 must be less than 3
// Postcondiciones: R9 is incremented by 1 and then displays the number
// Autor: Daniel A. Crespo 
// Fecha:11/Mar/2021
nextNumber:                             ; Loops through numbers 0-9
        cmp     #9,R9                   ; Resets the number back to 0 meaning
        jeq     resetNumber             ; the user has accidentaly missed the 
                                        ; desired number
        inc     R9                      ; Increment the number by 1
        call    #displayNumber          ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: Reset the number back to 0
// Precondiciones: R9 must be 9
// Postcondiciones: Changes R9 to 0 and displays the number
// Autor: Daniel A. Crespo 
// Fecha:11/Mar/2021
resetNumber:                            ; Resets the number back to 0
        mov     #0,R9                   ; Number is set back to 0
        call    #displayNumber          ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: Changes the state of the program to the next state and decides what to do next
// Precondiciones: R4 bust be 2
// Postcondiciones: increment R8 by one
// Autor: Daniel A. Crespo 
// Fecha:11/Mar/2021
nextState:                              ; Moves to the next state of the application
        push    R9                      ; Save the number in the stack
        mov     #0,R9                   ; Reset R9
        inc     R8                      ; Increment to the next state
        cmp     #3,R8                   ; If the program is on stage 3 then
        jeq     nextOperation           ; now we display the operation 
        cmp     #7,R8                   ; If the program is on stage 7 then the
        jeq     doTheMath               ; user has finish inputting all the data
                                        ; and is now expecting an answer
        call    #displayNumber          ; Display the next digit to the user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: Loops through each operation and displays it to the user
// Precondiciones: R8 bust be 3 (Third state)
// Postcondiciones: Increments R9 that represents the operation 
// Autor: Daniel A. Crespo 
// Fecha:11/Mar/2021
nextOperation:                          ; Loops through operations +,-,*,/
        cmp     #3,R9                   ; Resets the number back to 0 meaning
        jeq     resetOperation          ; the user has accidentaly missed the 
                                        ; desired operation
        inc     R9                      ; Increment to the next operation
        call    #displayOperation       ; Display the next operation to the user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: Subroutine used for reverting back to the plus operation
// Precondiciones: R9 must be 3
// Postcondiciones: Changes R9 to 0 and displays the operation
// Autor: Daniel A. Crespo 
// Fecha:11/Mar/2021
resetOperation:                         ; Reset operation back to +
        mov     #0,R9                   ; Number is set back to 0
        call    #displayOperation       ; Display the next operation to the user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: This subroutine saves the operation to a stack and proceeds
// to display the number 0 on the screen
// Precondiciones: R4 must be 2 meaning the user has pressed the right button
// Postcondiciones: calls displayNumber and displays the number 0 to the user
// Autor: Daniel A. Crespo 
// Fecha:11/Mar/2021
operationSelected:                      ; User has decided the operation
        inc     R8                      ; Increment to the next state
        push    R9                      ; Save the operation in the stack
        mov     #0,R9                   ; Reset R9
        call    #displayNumber          ; Display 0 to the user
        jmp mainLoop                    ; Keep waiting for user input

// Objetivo: Subroutine used for checking if the user is still holding down the button
// Precondiciones: If R4 = 4 or 2 then keep looping
// Postcondicione: Else wait for delay and end subroutine
// Autor: Daniel A. Crespo 
// Fecha:11/Mar/2021
stillHoldDown:                          ; User is still holding down the button
        mov.b   &P1IN,R4                ; Copy into R4 P1IN's byte
        and.b   #00000110B,R4           ; Compares which button is being pressed
        cmp.b   #00000100B,R4           ; Left button (P1.1) is being pressed
        jeq     stillHoldDown           ; If true wait for user to stop holding 
                                        ; down the button
        cmp.b   #00000010B,R4           ; Right button (P1.2) is being pressed
        jeq     stillHoldDown           ; If true wait for user to stop holding 
                                        ; down the button
        call    #delay                  ; Delay to help combat button bouncing
        ret                             ; User has finally let go of the button

// Objetivo: Subroutine use to add delay for the application
// Precondiciones: N/A
// Postcondiciones: N/A
// Autor: Daniel A. Crespo 
// Fecha:11/Mar/2021
delay:                                  ; Used to help against button bouncing
        mov     #0x2710,R13             ; Represents the delay to wait for
                                        ; button bouncing
    decrement:                          ; Label used for looping
        dec     R13                     ; Decrement delay by 1
        jnz     decrement               ; Keep Looping until delay = 0
        ret                             ; Delay finished

// Objetivo: Subroutine thats in charge of determining what operation to do
// Precondiciones: R8 must be 7 that means that the application is now on the 7th state
// Postcondiciones: Operation is chosen based on R9
// Autor: Daniel A. Crespo 
// Fecha:11/Mar/2021
doTheMath:                              ; Mathimatical brain of the application
        pop     R12                     ; Least significant digit of second number
        pop     R11                     ; Second significant digit of second number
        pop     R10                     ; Most significant digit of second number
        pop     R9                      ; Represents the operation
        pop     R7                      ; Least significant digit of first number
        pop     R6                      ; Second significant digit of first number
        pop     R5                      ; Most significant digit of first number
        call    #combineDigits          ; Subroutine for combining digits
        cmp     #1,R9                   ; R9=1 means the operation chosen is add
        jeq     addNumbers              ; Call the add operation
        cmp     #2,R9                   ; R9=2 means the operation chosen is sub
        jeq     subNumbers              ; Call the sub operation
        cmp     #3,R9                   ; R9=3 means the operation chosen is mul
        jeq     mulNumbers              ; Call the mul operation
        cmp     #0,R9                   ; R9=0 means the operation chosen is dev
        jeq     devNumbers              ; Call the dev operation

// Objetivo: Tomar digitos individuales de ambos números y guardar número en un solo registro
// Precondiciones: R5, R6, R7 contienen los digitos del primer número en orden.
// Mientras que R10,R11, y R12 contienen los digitos del segundo número en orden
// Postcondiciones: R14 contiene el primer número y R15 contiene el segundo número
// Autor: Joshua Cruz Cintrón
// Fecha: 13/marzo/2021
combineDigits:                          ; Subroutine for combining digits
    firstDigitCombine:   
        cmp     #0,R5
        jeq     secondDigitCombine
        add     #100, R14               ; This subroutine will add 100 to R14 
        dec     R5                      ; and decrease R5 by one until R5 is 0
        jmp     firstDigitCombine
    secondDigitCombine:     
        cmp     #0,R6
        jeq     thirdDigitCombine
        add     #10, R14                ; This subroutine will add 10 to R14 
        dec     R6                      ; and decrease R6 by one until R6 is 0
        jmp     secondDigitCombine
    thirdDigitCombine:      
        add     R7, R14                 ; This will add the last digit to R14

    firstDigitCombine2:     
        cmp     #0,R10
        jeq     secondDigitCombine2
        add     #100, R15               ; This subroutine will add 100 to R14 
        dec     R10                     ; and decrease R5 by one until R5 is 0
        jmp     firstDigitCombine2
    secondDigitCombine2:    
        cmp     #0,R11
        jeq     thirdDigitCombine2
        add     #10, R15                ; This subroutine will add 100 to R14 
        dec     R11                     ; and decrease R5 by one until R5 is 0
        jmp     secondDigitCombine2
    thirdDigitCombine2:     
        add     R12, R15                ; This will add the last digit to R15
        ret

// Objetivo: Es número suma los 2 números y guarda el resultado en R14
// Precondiciones: R14 y R15 contienen los 2 números respectivamente
// Postcondiciones: R14 contiene el resultado de la suma
// Autor: Joshua Cruz Cintróm
// Fecha: 13/marzo/2021
addNumbers:                             ; Operation for adding 2 numbers
        add     R15,R14                 ; Adds numbers in R14 and R15 and
                                        ; stores the result in R14
        mov     #0,R15                  ; Set R15 to 0 because we need it later
        cmp     #0,R14                  ; Check if the result = 0
        jeq     display0                ; If result = 0 then display 0
        jmp     seperateDigits          ; Seperate the digits into diferent registers
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: Multiplicar los 2 números y guardarlo en 1 registro, o 2 de ser necesario
// Precondiciones: R14 y R15 contienen los 2 números respectivamente
// Postcondiciones: R14 contiene hasta las centenas del número, y R15 contiene
// los digitos por encima de mil
// Autor: Joshua Cruz Cintrón
// Fecha: 14/marzo/2021
mulNumbers:                             ; Operation for multiplying 2 numbers
        cmp     #0,R15                  ; Check if the R15 = 0
        jeq     display0                ; If R15 = 0 then result = 0 
        cmp     #0,R14                  ; Check if the R14 = 0
        jeq     display0                ; If R14 = 0 then result = 0 
    multSetup:                          ; Setup numbers in the proper order
                                        ; for multiplication
        cmp     R14, R15                ; Compare which number is bigger
        jl      multAlgorithm           ; If R14>R15 then multiply both numbers
        call    #multSwitchNumbers      ; If R15>R14 then reverse both numbers
    multAlgorithm:                      ; Algorithm for multiplying 2 numbers
        mov     R14, R6                 ; Re-aranging data for multiplication
        mov     R15, R7                 ; Re-aranging data for multiplication
        mov     #0, R15                 ; Set R15 to 0 because we need it later
    multLoop:                           ; Lable used for looping
        dec     R7                      ; Decrement by 1
        jz      multDone                ; Multiplication is finished
        add     R6, R14                 ; Remember that multiplication is
                                        ; just a series of additions
        cmp     #10000, R14             ; If R14 is greater or equal than 1000
        jge     multReachedThousand     ; save that thousand on another register
        jmp     multLoop                ; Multiplication not done
    multDone:                           ; Multiplication finished
        jmp     seperateDigits          ; Seperate the digits into diferent registers
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: Restarle mil a R14 y añadirle 1 a R15 para representar números de
// más de 3 dígitos usando 2 registros
// Precondiciones: R14 es igual a mil, R15 contiene los "miles" del número que
// se está calculando
// Postcondiciones: R14 es igual a 0, a R15 se le suma 1
// Autor: Joshua Cruz Cintrón
// Fecha: 14/marzo/2021
multReachedThousand:                    ; Save that thousand on R15
        sub     #10000,R14              ; Sub 1000-R14 so we can move that to R15
        inc     R15                     ; Increment 1 meaning the first thousand
        jmp     multLoop                ; Go back to multiplying

// Objetivo: Intercambiar los 2 números de registros
// Precondiciones: R14 contiene el número menor
// Postcondiciones: R14 contiene el número mayor
// Autor: Joshua Cruz Cintrón
// Fecha: 14/marzo/2021
multSwitchNumbers:                      ; Invert the data on both R14 and R15
        push     R15                    ; Pushed to the stack so we dont 
                                        ; override the data
        mov      R14, R15               ; Swap R14 to R15
        pop      R14                    ; Retrieve the data from the stack
        ret                             ; Swapping done

// Objetivo: Tomar el valor almacenado en R14 y restarlo con el valor almacenado 
// en R15; el resultado se guarda en R14 (R14 = R14 - R15).
// Precondiciones: En R14 esta almacenado el primer numero en binario y en R15 
// esta almacenado el segundo numero en binario.
// Postcondiciones: El resultado de la resta estara almacenado en R14 
// en formato 2s complement y R15 siempre sera 0.
// Autor: Abdiel Cortes
// Fecha: 13/Marzo/2021
subNumbers:                             ; Operation for subtracting 2 numbers
        sub     R15, R14                ; R14 = R14 - R15
        mov     #0,R15                  ; Set R15 to 0 because we need it later
        cmp     #0,R14                  ; Check if the result = 0
        jeq     display0                ; If result = 0 then display 0
        jmp     seperateDigits          ; Seperate the digits into diferent registers
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: Tomar el valor almacenado en R14 y dividirlo con el valor almacenado 
// en R15; el resultado se guarda en R14 (R14 = R14 / R15).
// Precondiciones: En R14 esta almacenado el primer numero en binario y en R15 
// esta almacenado el segundo numero en binario.
// Postcondiciones: El resultado de la division estara almacenado en R14 y en R5;
// R15 siempre sera 0.
// Autor: Abdiel Cortes
// Fecha: 13/Marzo/2021
devNumbers:                             ; Operation for deviding 2 numbers
        cmp     #0,R15                  ; Check if the denominator is 0
        jeq     ceroIsOnDenominator     ; If 0 then show error
        cmp     #0,R14                  ; Check if the numerator is 0
        jeq     ceroIsOnNumerator       ; If 0 then result = 0
        mov     #0, R5                  ; R5 = quotient = 0   
        
    divLoop:                            ; Lable used for looping
        sub     R15, R14                ; R14 = R14 - R15
        cmp     #0, R14                 ; Compare to see if we can keep subtracting
        jl      divEnd                  ; R14 < 0, its negative so we subtracted
                                        ; too much
        inc     R5                      ; Quotient += 1
        jmp     divLoop                 ; Keep dividing    
   
    divEnd:                             ; Division finished
        mov     R5, R14                 ; Save result in R14
        mov     #0,R15                  ; Set R15 to 0 because we need it later
        cmp     #0,R14                  ; Check if the result = 0
        jeq     display0                ; If result = 0 then display 0
        jmp     seperateDigits          ; Seperate the digits into diferent registers
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: Displays the number 0 on the screen meaning that is the final
// answer of that operation
// Precondiciones: R14 must be 0
// Postcondiciones: Display the number 0 on the screen
// Autor: Daniel A. Crespo 
// Fecha:14/Mar/2021
ceroIsOnNumerator:                      ; Cero is on numerator meaning result=0
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        call    #displayFirstSegment    ; Display number to user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: Subroutine used for calling another subroutine named displayError
// meaning that the denominator is 0 which can not be calculated when dividing
// Precondiciones: R15 must be 0
// Postcondiciones: call displayError subroutine to dispay an error message to the user
// Autor: Daniel A. Crespo 
// Fecha:14/Mar/2021
ceroIsOnDenominator:                    ; Cero is on denominator meaning an error
        call    #displayError           ; Display error to user
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: Muestra un cero en el primer segmento
// Precondiciones: R9 representa el numero a ser mostrado
// Postcondiciones: R9 siempre ser cero al final
// Autor: Rey J. Cotto
// Fecha: 13/03/21
display0:                               ; Display the number 0 to the user
        mov     #0,R9                   ; R9 represents the number to be printed
        call    displayFirstSegment     ; Display the number on the first segment
        jmp     mainLoop                ; Keep waiting for user input 

// Objetivo: Separar en digitos decimales el numero binario almacenado en R14 
// (o para el caso de la multiplicacion en R14 y R15).
// Precondiciones: Para el caso de la suma y division, se encuentra el resultado 
// en binario almacenado en R14. Para la resta el resultado se encuentra almacenado en R14 
// en formato binario 2s complement. Para la multiplicacion el resultado se encuentra
// en los registros R14 y R15; los 3 digitos mas significativos en R15 y los 3 digitos
// menos significativos en R14. En R9 se encuentra un valor que te dice que tipo
// de operacion se llevo a cabo (suma=1, resta=2, multiplicacion=3, division=0).
// Postcondiciones: Los digitos decimales se encontraran en formato binario almacenado
// en los registros R5, R6, R7, R10, R11 y R12; donde R5 es el digito menos significativo
// y R12 es el digito mas significativo. Si el resultado es un numero negativo, 
// entonces se almacenara 1 en R13.
//     ejemplo: -123
//     R5 = 3, R6 = 2, R7 = 1, R10 = junk, R11 = junk, R12 = junk, R13 = 1
// Autor: Abdiel Cortes
// Fecha: 14/Marzo/2021
seperateDigits:                         ; Separeates R14 into its decimal components
        cmp     #2, R9                  ; Subtraction, always 3 digits, but sometimes
        jeq     sepDigSub               ; it's negative so we have to account for that
        jmp     seperate                ; Any other operation gets seperated the same way

// Objetivo: Verificar si el resultado de la resta fue un numero negativo.
// Precondiciones: En R14 se encuentra el resultado en binario 2s complement.
// Postcondiciones: Si el numero es positivo se llamara la subrutina seperate.
// Si el numero es negativo se llamara la subrutina applyNegative.
// Autor: Abdiel Cortes
// Fecha: 14/Marzo/2021
sepDigSub:                              ; Checks if R14 is negative
        push    R14                     ; Store R14 in stack
        and     #1000000000000000b, R14 ; Apply bit mask
                                        ; If most significant bit is 1, then its a negative number
        cmp     #0,R14                  ; If R14 == 0, then most significant bit is 0
        pop     R14                     ; Restore value of R14
        jeq     seperate                ; R14 is a positive number
        jmp     applyNegative           ; R14 is a negative number

// Objetivo: Subrutina que crea un flag al R13 representando si el numero
// calculado es positivo o negativo
// Precondiciones: R14 must be a negative number
// Postcondiciones: R13 will contain 1 meaning that the number is negative
// Autor: Abdiel Cortes
// Fecha: 14/Marzo/2021
applyNegative: 
        inv     R14                     ; Convert R14 to positive, first invert everything,
        inc     R14                     ; Then add 1
        mov     #1,R13                  ; Add negative flag
        jmp     seperate                ; Seperate the digits

// Objetivo: Seperate the result found on both R14 and R15 into individual digits
// Precondiciones: Some value has to be stored at least in R14, R12 is needed 
// as a counter for digits, R11 is needed as a counto for how many are in the
// stack, R9 is needed for saving the seperated digit from result, R4 is needed
// for subtracting the result by the specified tens
// Postcondiciones: The stack will have the results seperated by digits in oder 
// of most significant to least significant digit
// Autor: Daniel A. Crespo 
// Fecha:15/Mar/202
seperate:                               ; Subroutine used for seperating the 
                                        ; results found in R14 and R15 (if any) 
        mov     #3,R12                  ; R12 serves as a counter for seperating
                                        ; each digit. At first it removes whats 
                                        ; inside R15
        mov     #0,R11                  ; R11 serves as a counter for seperating
                                        ; 6 digits
    loop:                               ; Lable used for looping
        dec     R12                     ; Decrements by 1 meaning seperate to 
                                        ; the next lower tenses 
        mov     #0, R9                  ; R9 = quotient = 0
        cmp     #1,R12                  ; R12=1 means seperate by ones
        jeq      ones                   ; Seperate ones
        cmp     #2,R12                  ; R12=2 means seperate by tens
        jeq      tens                   ; Seperate tens
        cmp     #3,R12                  ; R12=2 means seperate by hundreds
        jeq     hundreds                ; Seperate hundreds
        cmp     #0,R12                  ; R12=0 means it's done seperating
        jeq     otherRegister           ; Switch whats inside register R14 to R15
                                        ; or it means that seperation is finished
        jmp     thousands               ; R12=4 means seperate by thousands
        
    otherRegister:                     
        cmp     #6,R11                  ; R11=6 means that 6 digits where seperated
        jeq     finished                ; Seperation of digits is completed 
        mov     R14,R15                 ; Switch what is in R14 to R15
        mov     #0,R14                  ; Clear R14 because the data is now on R15
        mov     #5,R12                  ; R12=5 meaning that it should loop 4 
                                        ; more times so we can seperate what is inside R14
        jmp     loop                    ; Keep looping
    
    ones:                               ; If we are seperating the ones then
        mov     R15,R9                  ; move R15 to R9 because its already in 
                                        ; the tense form
        mov     #0,R15                  ; Clear R15 for later use
        jmp     pushDigit               ; Push the digit on the stack

    tens:                               ; If we are seperating the tens then
        mov     #10,R4                  ; set R4 to 10 so we can subtract by tens
        jmp     subWithTenses           ; Sub R15 at the specified tens
        
    hundreds:                           ; If we are seperating the hundreds then
        mov     #100,R4                 ; set R4 to 100 so we can subtract by hundreds
        jmp     subWithTenses           ; Sub R15 at the specified tens
        
    thousands:                          ; If we are seperating the thousands then
        mov     #1000,R4                ; set R4 to 1000 so we can subtract by thousands
        jmp     subWithTenses           ; Sub R15 at the specified tens
    
        
    subWithTenses:                      ; General subroutine to seperate digits
                                        ; by the specified tens
        cmp     R4,R15                  ; R4<R5 means that the number is a lower tens
        jl      pushDigit               ; Push the digit to the stack
        sub     R4,R15                  ; Sub R4-R15 by the specified tens
        inc     R9                      ; Increment R9 by 1 meaning its the quotient
        jmp     subWithTenses           ; Keep subtracting by the specified tens
    
    pushDigit:                          ; Push digit on the stack for later use
        push    R9                      ; Push R9 = quotient = seperated digit
        inc     R11                     ; Increment R11 by 1 meaning we have 1 more saved digit
        jmp     loop                    ; Restart the loop again

    finished:                           ; Seperation of digits is completed
      ; This is done to reverse the stack for proper display of the results
        pop     R12
        pop     R11
        pop     R10
        pop     R7
        pop     R6
        pop     R5
        push    R12
        push    R11
        push    R10
        push    R7
        push    R6
        push    R5
        jmp     displayResults          ; Display results to the user

// Objetivo: Subrutina diseñada para mostrar los numeros resultantes en la
// pantalla, en su posicion adecuada
// Precondiciones: R10 representa el numero resultante
// Postcondiciones: El numero va a estar mostrado en la pantalla
// Autor: Rey J. Cotto
// Fecha: 14/03/21
displayResults:                         ; Subroutine used for displaying the results
        mov     #7,R10                  ; R10 represents the 6 digits we are going to display
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        mov     #0,R11                  ; R11 is used as a flag for if digit has 
                                        ; 0 on the left side of the result, but 
                                        ; it also serves as an indicator as to 
                                        ; were to display the number
    displayNextDigit:                   ; Lable used for looping the next digit to display
        dec     R10                     ; Decrement R10 by 1 meaning a digit is
                                        ; being displayed
        cmp     #0,R10                  ; R10=0 it means that all digits have been displayed
        jeq     resultsDone             ; Result has finally finished printing
        pop     R9                      ; Pop the digit from the stack
        cmp     #1,R11                  ; If R11 >= 1 then that means that their are
        jge     noMoreLeftZeros         ; no mores zeros to the left of the number
        cmp     #0,R9                   ; If R9=0 that means that a zero was
        jeq     displayNextDigit        ; found on the left of the digit so skip
    noMoreLeftZeros:                    ; No more zeros found on the left side
        inc     R11                     ; Increment R11 by 1 to display the next
                                        ; digit on the next display segment
        cmp     #1,R11                  ; R11=1 means that the first display
                                        ; segment can be used for displaying the digit
        jeq     displayFirstDigit       ; Display digit on the first segment
        cmp     #2,R11                  ; R11=2 means that the second display
                                        ; segment can be used for displaying the digit
        jeq     displaySecondDigit      ; Display digit on the second segment
        cmp     #3,R11                  ; R11=3 means that the third display
                                        ; segment can be used for displaying the digit
        jeq     displayThirdDigit       ; Display digit on the third segment
        cmp     #4,R11                  ; R11=4 means that the fourth display
                                        ; segment can be used for displaying the digit
        jeq     displayFourthDigit      ; Display digit on the fourth segment
        cmp     #5,R11                  ; R11=5 means that the fifth display
                                        ; segment can be used for displaying the digit
        jeq     displayFifthDigit       ; Display digit on the fifth segment
        cmp     #6,R11                  ; R11=6 means that the sixth display
                                        ; segment can be used for displaying the digit
        jeq     displaySixthDigit       ; Display digit on the sixth segment
        
    displayFirstDigit:                  ; Display digit on the first segment
        call    #displayFirstSegment    ; Call subroutine for displaying digit 
                                        ; on the first segment display
        cmp     #1,R13                  ; R13 represents a flag meaning if the
                                        ; number is negative (1) or positive (0)
        jeq     displayNegative         ; If it's a negative number then display
                                        ; the negative sign
        jmp     displayNextDigit        ; Go to the next digit for displaying
        
    displaySecondDigit:                 ; Display digit on the second segment
        call    #displaySecondSegment   ; Call subroutine for displaying digit 
                                        ; on the second segment display
        jmp     displayNextDigit        ; Go to the next digit for displaying
        
    displayThirdDigit:                  ; Display digit on the Third segment
        call    #displayThirdSegment    ; Call subroutine for displaying digit 
                                        ; on the Third segment display
        jmp     displayNextDigit        ; Go to the next digit for displaying
        
    displayFourthDigit:                 ; Display digit on the Fourth segment
        call    #displayFourthSegment   ; Call subroutine for displaying digit 
                                        ; on the Fourth segment display
        jmp     displayNextDigit        ; Go to the next digit for displaying
        
    displayFifthDigit:                  ; Display digit on the Fifth segment
        call    #displayFifthSegment    ; Call subroutine for displaying digit 
                                        ; on the Fifth segment display
        jmp     displayNextDigit        ; Go to the next digit for displaying
        
    displaySixthDigit:                  ; Display digit on the Sixth segment
        call    #displaySixthSegment    ; Call subroutine for displaying digit 
                                        ; on the Sixth segment display
        jmp     displayNextDigit        ; Go to the next digit for displaying
        
    resultsDone:                        ; Result has finally finished printing
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: Subrutina diseñada para mostrar el signo negativo
// Precondiciones: El negative flag fue activado y entro a la subrutina
// Postcondiciones: El simbolo de negativo esta mostrado en la pantalla
// Autor: Rey J. Cotto
// Fecha: 14/03/21
displayNegative:                        ; Display the negative sign found on the
                                        ; first segment display
        bis.b   #4,&0x0A29+1            ; Code used for turning on the - sign on
                                        ; the first segment display
        jmp     displayNextDigit        ; Go to the next digit for displaying

// Objetivo: Subrutina diseñada para mostrar los numeros no finales,
// en su posicion adecuada
// Precondiciones: R8 representa el estado del programa
// Postcondiciones: Alguna subrutina va a ser llamada al final como resultado de esta
// Autor: Rey J. Cotto
// Fecha: 14/03/21
displayNumber:                          ; Subroutine used for displaying numbers
                                        ; based on the state the program is in
        cmp     #0,R8                   ; If R8 is at state 0 then display the 
        jeq     displayFirstSegment     ; number on the first segment display
        cmp     #1,R8                   ; If R8 is at state 1 then display the
        jeq     displaySecondSegment    ; number on the second segment display
        cmp     #2,R8                   ; If R8 is at state 2 then display the
        jeq     displayThirdSegment     ; number on the third segment display
        cmp     #3,R8                   ; If R8 is at state 3 then display the
        jeq     displayOperation        ; Operation on the first segment display
        cmp     #4,R8                   ; If R8 is at state 4 then display the
        jeq     displayFirstSegment     ; number on the first segment display
        cmp     #5,R8                   ; If R8 is at state 5 then display the
        jeq     displaySecondSegment    ; number on the second segment display
        cmp     #6,R8                   ; If R8 is at state 6 then display the
        jeq     displayThirdSegment     ; number on the third segment display

// Objetivo: Mostrar la operacion a computar en la pantalla
// Precondiciones: R9 representa la posicion en la lista
// Postcondiciones: El simbolo va a ser mostrado en la pantalla
// Autor: Rey J. Cotto
// Fecha: 14/03/21
displayOperation:                       ; Display the operation based on R9
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        mov.b   operH(R9),&0x0A29       ; R9 represents the position fo the list
                                        ; of hexadecimal numbers that represents
        mov.b   operL(R9),&0x0A29+1     ; the operations such as +,-,*,/
        ret                             ; Display done

// Objetivo:Mostrar un mensaje de error al usuario
// Precondiciones: R15 tiene que ser igual a 0 que significa que se esta 
// dividiendo un numero entre 0
// Postcondiciones: Desplegar un mensaje de error en el display
// Autor: Daniel A. Crespo 
// Fecha:13/Mar/2021
displayError:                           ; This display an error message when
                                        ; user decides to devide by 0
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        mov     #0,R9                   ; R9 represents the position of the list
        mov.b   errorH(R9),&0x0A29      ; Display the letter E
        mov.b   errorL(R9),&0x0A29+1    ; Display the letter E
        mov     #1,R9                   ; R9 represents the position of the list
        mov.b   errorH(R9),&0x0A25      ; Display the letter R
        mov.b   errorL(R9),&0x0A25+1    ; Display the letter R
        mov     #1,R9                   ; R9 represents the position of the list
        mov.b   errorH(R9),&0x0A23      ; Display the letter R
        mov.b   errorL(R9),&0x0A23+1    ; Display the letter R
        mov     #2,R9                   ; R9 represents the position of the list
        mov.b   errorH(R9),&0x0A32      ; Display the letter O
        mov.b   errorL(R9),&0x0A32+1    ; Display the letter O
        mov     #1,R9                   ; R9 represents the position of the list
        mov.b   errorH(R9),&0x0A2E      ; Display the letter R
        mov.b   errorL(R9),&0x0A2E+1    ; Display the letter R
        jmp     mainLoop                ; Keep waiting for user input

// Objetivo: Subrutina diseñada para mostrar en el primer segmento del LCD
// Precondiciones: R9 contiene la posicion a ser mostrada
// Postcondiciones: Se estara mostrando lo indicado en el primer segmento
// Autor: Rey J. Cotto
// Fecha: 14/03/21
displayFirstSegment:                    ; Soubroutine used for displaying on the
                                        ; first segment display
        mov.b   digitH(R9),&0x0A29      ; Display the high byte of digitH at position R9
        mov.b   digitL(R9),&0x0A29+1
        ret

// Objetivo: Subrutina diseñada para mostrar en el segundo segmento del LCD
// Precondiciones: R9 contiene la posicion a ser mostrada
// Postcondiciones: Se estara mostrando lo indicado en el segundo segmento
// Autor: Rey J. Cotto
// Fecha: 14/03/21
displaySecondSegment:                   ; Soubroutine used for displaying on the
                                        ; first segment display
        mov.b   digitH(R9),&0x0A25      ; Display the high byte of digitH at position R9
        mov.b   digitL(R9),&0x0A25+1
        ret

// Objetivo: Subrutina diseñada para mostrar en el tercer segmento del LCD
// Precondiciones: R9 contiene la posicion a ser mostrada
// Postcondiciones: Se estara mostrando lo indicado en el tercer segmento
// Autor: Rey J. Cotto
// Fecha: 14/03/21
displayThirdSegment:                    ; Soubroutine used for displaying on the
                                        ; first segment display
        mov.b   digitH(R9),&0x0A23      ; Display the high byte of digitH at position R9
        mov.b   digitL(R9),&0x0A23+1
        ret

// Objetivo: Subrutina diseñada para mostrar en el cuarto segmento del LCD
// Precondiciones: R9 contiene la posicionon a ser mostrada
// Postcondiciones: Se estara mostrando lo indicado en el cuarto segmento
// Autor: Rey J. Cotto
// Fecha: 14/03/21
displayFourthSegment:                   ; Soubroutine used for displaying on the
                                        ; first segment display
        mov.b   digitH(R9),&0x0A32      ; Display the high byte of digitH at position R9
        mov.b   digitL(R9),&0x0A32+1    ; Display the low byte of digitL at position R9
        ret

// Objetivo: Subrutina diseñada para mostrar en el quinto segmento del LCD
// Precondiciones: R9 contiene la posicion a ser mostrada
// Postcondiciones: Se estara mostrando lo indicado en el quinto segmento
// Autor: Rey J. Cotto
// Fecha: 14/03/21
displayFifthSegment:                    ; Soubroutine used for displaying on the
                                        ; first segment display
        mov.b   digitH(R9),&0x0A2E      ; Display the high byte of digitH at position R9
        mov.b   digitL(R9),&0x0A2E+1    ; Display the low byte of digitL at position R9
        ret

// Objetivo: Subrutina diseñada para mostrar en el sexto segmento del LCD
// Precondiciones: R9 contiene la posicion a ser mostrada
// Postcondiciones: Se estara mostrando lo indicado en el sexto segmento
// Autor: Rey J. Cotto
// Fecha: 14/03/21
displaySixthSegment:                    ; Soubroutine used for displaying on the
                                        ; first segment display
        mov.b   digitH(R9),&0x0A27      ; Display the high byte of digitH at position R9
        mov.b   digitL(R9),&0x0A27+1    ; Display the low byte of digitL at position R9
        ret

fin:    JMP $                           ; jump to current location '$'
                                        ; (endless loop)
        END
