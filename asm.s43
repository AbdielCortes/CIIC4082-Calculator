#include "msp430.h"                     ; #define controlled include file
//To do list:
        //juntar los 3 dijitos
        //separar el resultado a 3 dijitos
        //nextOperation needs to be finished
        //doTheMath needs to be finished
        //addNumbers needs to be finished
        //subNumbers needs to be finished
        //mulNumbers needs to be finished
        //devNumbers needs to be finished
        //setDisplayNumber0 needs to be finished
        //displayNumber needs to be finished
        //displayOperation needs to be finished
        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        
        ORG     01C00h                  ; start of ram

//PRE-DEFINED VALUES START HERE

//PRE-DEFINED VALUES END HERE

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   mov     #SFE(CSTACK), SP        ; set up stack

main:   nop                             ; main program
        mov   #WDTPW+WDTHOLD,&WDTCTL    ; Stop watchdog timer
        mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
        bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as
                                        ; as pull-down
        
        ; Initialize LCD
        MOV.W   #0xffff,&LCDCPCTL0
        MOV.W   #0xfc3f,&LCDCPCTL1
        MOV.W   #0x0fff,&LCDCPCTL2
        mov.w   #0x041e,&LCDCCTL0
        mov.w   #0x0208,&LCDCVCTL
        mov.w   #0x8000,&LCDCCPCTL
        mov.w   #2,&LCDCMEMCTL
        bis.w   #1,&LCDCCTL0
        
        
        bic.w   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on by default
  

setupCalc:
        mov     #0,R5                   ; Represents the first number the
                                        ; user has inputted 
        mov     #0,R6                   ; Represents the second number the
                                        ; user has inputted 
        mov     #0,R7                   ; Represents the third number the
                                        ; user has inputted 
        mov     #0,R8                   ; Represent the state, the program is on
        mov     #0,R9                   ; Used for knowing the number/operation
                                        ; to display next    
        mov     #0,R10                  ; Represents the first number the
                                        ; user has inputted 
        mov     #0,R11                  ; Represents the second number the
                                        ; user has inputted 
        mov     #0,R12                  ; Represents the third number the
                                        ; user has inputted    
        mov     #100,R13               ; Represents the delay to wait for
                                        ; button bouncing
        mov     #0,R14                  ; Represents the first full number the
                                        ; user inputted
        mov     #0,R15                  ; Represents the second full number the
                                        ; user inputted
        jmp     setDisplayNumber0       ; Set the display to show a 0
                   
mainLoop:                               ; The brains of the application
        mov.b   &P1IN,R4                ; Copy into R4 P1IN's byte
        ;cmp     #4,R4
        ;jnz     mainLoop
        
        

    checkState:                         ; Checks the state of the application
                                        ; and decide what to do next
        cmp     #3,R8                   ; If state is less than 3 means that the 
        jl      incNumberLoop           ; user is still inputting the number
        jeq     incOperationLoop        ; User is now inputting an operation
        cmp     #7,R8                   ; If state is less than 6 means that the
        jl      incNumberLoop           ; user is still inputting the number 
        jeq     doTheMath               ; User has finish inputting all the data
                                        ; and is now expecting an answer
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     setupCalc               ; If true then restart calculator
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     setupCalc               ; If true then restart calculator
        cmp.b   #00000000B,R4           ; Compares if both button are 
                                        ; being pressed
        jeq     setupCalc               ; If true then restart calculator
        jmp     mainLoop                ; Keep waiting for user input

    incNumberLoop:                      ; Loop for incrementing the number
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     increment               ; If true then increment the number
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     nextNumber              ; User has decided to input next number
        jmp     mainLoop                ; Keep waiting for user input

    incOperationLoop:                   ; Cycles through the operations
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     nextOperation           ; If true then change the operation
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     operationSelected       ; User has decided the operation, so now
                                        ; we reset to display the next number
        jmp     mainLoop                ; Keep waiting for user input

increment:                              ; Subroutine that increments the number
                                        ; by 1 and circles back to 0
        cmp     #9,R9                   ; Resets the number back to 0 meaning
        jeq     resetNumber             ; the user has accidentaly missed the 
                                        ; desired number
        inc     R9                      ; Increment the number by 1
        call    #displayNumber          ; Display the new number to the user
        call    #delay                  ; Delay to help combat button bouncing
        call    #stillHoldDown          ; Verify if the user is still holding 
                                        ; down the button
        jmp     mainLoop                ; Keep waiting for user input
        
resetNumber:                            ; Resets the number back to 0
        mov     #0,R9                   ; Number is set back to 0
        call    #displayNumber          ; Display the new number to the user
        call    #delay                  ; Delay to help combat button bouncing
        call    #stillHoldDown          ; Verify if the user is still holding 
                                        ; down the button
        jmp     mainLoop                ; Keep waiting for user input

nextNumber:
        push    R9                      ; Save the number in the stack
        mov     #0,R9                   ; Set the number to 0
        inc     R8                      ; Increment to the next state of 
                                        ; the program
        cmp     #3,R8                   ; If the program is on stage 3 then
        jeq     nextOperation           ; now we display the operation 
        call    #displayNumber          ; Display the new number to the user
        call    #delay                  ; Delay to help combat button bouncing
        call    #stillHoldDown          ; Verify if the user is still holding 
                                        ; down the button
        jmp     mainLoop                ; Keep waiting for user input

nextOperation:
        cmp     #4,R9                   ; Resets the operation back to plus
        jeq     resetOperation          ; meaning the user has accidentaly 
                                        ; missed the desired operation
        inc     R9
        cmp     #1,R9
        jeq     displayAdd
        cmp     #2,R9
        jeq     displaySub
        cmp     #3,R9
        jeq     displayMul
        cmp     #4,R9
        jeq     displayDiv
        jmp     mainLoop                ; Keep waiting for user input

resetOperation:
        mov     #0,R9                   ; We go back to display
        jmp     nextOperation           ; the first operation

operationSelected: 
        inc     R8
        mov     #0,R9
        push    R9
        jmp     setDisplayNumber0
        
setDisplayNumber0:
        mov.b   #11111100B,&0xA29       ; Display number zero in LCD
        jmp mainLoop

displayAdd:
        mov.b   #00000011B,&0xA29       ; Display the horizontal line for the sum symbol
        mov.b   #01010000B,&0xA2A       ; Display the vertical line for the sum symbol
        call    #delay                  ; Delay to help combat button bouncing
        call    #stillHoldDown          ; Verify if the user is still holding 
                                        ; down the button
        jmp     mainLoop
        
displaySub:
        mov.b   #00000011B,&0xA29       ; Display the horizontal line for the minus symbol
        call    #delay                  ; Delay to help combat button bouncing
        call    #stillHoldDown          ; Verify if the user is still holding 
                                        ; down the button
        jmp     mainLoop

displayMul:
        mov.b   #10101010B,&0xA2A       ; Display the cross for the mult. symbol
        call    #delay                  ; Delay to help combat button bouncing
        call    #stillHoldDown          ; Verify if the user is still holding 
                                        ; down the button
        jmp     mainLoop

displayDiv:
        mov.b   #00101000B,&0xA2A       ; Display the diagonal line for the div. symbol
        call    #delay                  ; Delay to help combat button bouncing
        call    #stillHoldDown          ; Verify if the user is still holding 
                                        ; down the button
        jmp     mainLoop

stillHoldDown:
        call    #delay
        mov.b   &P1IN,R4                ; Copy into R4 P1IN's byte
        and.b   #00000110B,R4           ; Compares which button is being pressed
        cmp.b   #00000100B,R4           ; Left button (P1.1) is being pressed
        jeq     stillHoldDown           ; If true wait for user to stop holding 
                                        ; down the button
        cmp.b   #00000010B,R4           ; Right button (P1.2) is being pressed
        jeq     stillHoldDown           ; If true wait for user to stop holding 
                                        ; down the button
        ret                             ; User has finally let go of the button

delay:
        dec     R13
        jnz     delay
        mov     #100,R13
        ret

doTheMath:
        inc     R8
        pop     R12
        pop     R11
        pop     R10
        pop     R9
        pop     R7
        pop     R6
        pop     R5
        call    #combineDigits
        ;cmp     ,R9
        jeq     addNumbers
        ;cmp     ,R9
        jeq     subNumbers
        ;cmp     ,R9
        jeq     mulNumbers
        ;cmp     ,R9
        jeq     devNumbers
        jmp     mainLoop

combineDigits:
        //Combine the first number (R5,R6,R7) and save it in R14
        //Combine the second number (R10,R11,R12) and save it in R15
        ret

addNumbers:
        //Add R14+R15
        call    #seperateDigits
        call    #displayNumber
        jmp     mainLoop

subNumbers:
        //Sub R14-R15
        call    #seperateDigits
        call    #displayNumber
        jmp     mainLoop

mulNumbers:
        //Mul R14*R15
        call    #seperateDigits
        call    #displayNumber
        jmp     mainLoop

devNumbers:
        //Div R14/R15
        call    #seperateDigits
        call    #displayNumber
        jmp     mainLoop
        
seperateDigits:
        //Missing Code
        ret

displayNumber:
        cmp     #0,R9
        jeq     numZero
        cmp     #1,R9
        jeq     numOne
        cmp     #2,R9
        jeq     numTwo
        cmp     #3,R9
        jeq     numThree
        cmp     #4,R9
        jeq     numFour
        cmp     #5,R9
        jeq     numFive
        cmp     #6,R9
        jeq     numSix
        cmp     #7,R9
        jeq     numSeven
        cmp     #8,R9
        jeq     numEight
        cmp     #9,R9
        jeq     numNine
        ret

numZero:
        mov.b   #11111100B,&0xA29       ; Display number zero in LCD
        ret

numOne:
        mov.b   #01100000B,&0xA29       ; Display number one in LCD
        ret

numTwo:
        mov.b   #11011011B,&0xA29       ; Display number two in LCD
        ret
        
numThree:
        mov.b   #0xF1,&0xA29            ; Display number three in LCD
        ret

numFour:
        mov.b   #01100111B,&0xA29       ; Display number four in LCD
        ret

numFive:
        mov.b   #10110111B,&0xA29       ; Display number five in LCD
        ret

numSix:
        mov.b   #10111111B,&0xA29       ; Display number six in LCD
        ret

numSeven:
        mov.b   #11100000B,&0xA29       ; Display number seven in LCD
        ret

numEight:
        mov.b   #11111111B,&0xA29       ; Display number eight in LCD
        ret

numNine:
        mov.b   #11100111B,&0xA29       ; Display number nine in LCD
        ret



fin:    JMP $                           ; jump to current location '$'
                                        ; (endless loop)
        END
